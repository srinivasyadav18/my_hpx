/*
Proof of Concept for adding vectorization to Parallel Algorithms in HPX
=======================================================================

All the algorithms are implemented using
C style arrays  or raw  pointers.  These
implementation  are  for   demonstration 
puroposes only.

List of Algorithms show here : 
1. fill
2. generate
3. adjacent_difference
4. copy
5. count
6. any_of
7. none_of
8. all_of
9. equal
10. find
11. min, max, min_max
12. min_element, max_element
*/
#include <cstdalign>
#include <climits>
#include <omp.h>

//========================================================================
// 1. fill
//------------------------------------------------------------------------
// fills element in each array with the value.
// It only uses #pragma omp simd

void fill(int *arr, int size, int val)
{
    #pragma omp simd
    for (int i = 0; i < size; i++)
    {
        arr[i] = val;
    }
}
//========================================================================




//========================================================================
// 2. generate
//------------------------------------------------------------------------
// fills each element in array with the value generated by the generator.
// It uses #pragma omp declare simd for making the generator vectorizable.
// It uses #pragma omp simd to vectorize the loop body of algorithm.

#pragma omp declare simd
int generator()
{
    return 5;
};

void generate(int *arr, int size)
{
    #pragma omp simd
    for (int i = 0; i < size; i++)
    {
        arr[i] = generator();
    }
}
//========================================================================




//========================================================================
// 3. adjacent_difference
//------------------------------------------------------------------------
// computes the adjacent difference between two elements.
// Vectorizable only when source and destination arrays
// are different.
// It only uses #pragma omp simd.

void adjacent_difference(int *src, int *dest, int size)
{
    #pragma omp simd
    for (int i = 0; i < size; i++)
    {
        dest[i] = src[i+1] - src[i];
    }
}
//========================================================================




//========================================================================
// 4. copy
//------------------------------------------------------------------------
// Copies elements from source array to destination array
// It only uses #pragma omp simd.

void copy(int *src, int *dest, int size)
{
    #pragma omp simd
    for (int i = 0; i < size; i++)
    {
        dest[i] = src[i];
    }
}
//========================================================================




//========================================================================
// 5. count
//------------------------------------------------------------------------
// Count the occurances of the val.
// It uses #pragma omp simd reduction.

int count(int *arr, int size, int val)
{
    int count_ = 0;
    #pragma omp simd reduction(+:count_)
    for (int i = 0; i < size; i++)
    {
        if (val == arr[i]) count_++;
    }
    return count_;
}
//========================================================================




//========================================================================
// 6. any_of
//------------------------------------------------------------------------
// returns true if any of the element in the array satisfies the predicate.
// It uses #pragma omp simd reduction.

bool any_of (int *arr, int size)
{
    int count_ = 0;
    #pragma omp simd reduction(+:count_)
    for (int i = 0; i < size; i++)
    {
        if (arr[i] == 5) count_++;
    }

    if (count_ > 0) return true;
    return false;
}
//========================================================================




//========================================================================
// 7. none_of
//------------------------------------------------------------------------
// returns true if none of the element in the array satisfies the predicate.
// It uses #pragma omp simd reduction.

bool none_of (int *arr, int size)
{
    int count_ = 0;
    #pragma omp simd reduction(+:count_)
    for (int i = 0; i < size; i++)
    {
        if (arr[i] == 5) count_++;
    }

    if (count_ == 0) return true;
    return false;
}
//========================================================================




//========================================================================
// 8. all_of
//------------------------------------------------------------------------
// returns true if all the elements in the array satisfies the predicate.
// It uses #pragma omp simd reduction.

bool all_of (int *arr, int size)
{
    int count_ = 0;
    #pragma omp simd reduction(+:count_)
    for (int i = 0; i < size; i++)
    {
        if (arr[i] == 5) count_++;
    }

    if (count_ == size) return true;
    return false;
}
//========================================================================




//========================================================================
// 9. equal
//------------------------------------------------------------------------
// returns true if all the elements of both arrays are equal.
// It uses #pragma omp simd reduction.

bool equal (int *src, int *dest, int size)
{
    int count_ = 0;
    #pragma omp simd reduction(+:count_)
    for (int i = 0; i < size; i++)
    {
        if (src[i] == dest[i]) count_++;
    }

    if (count_ == size) return true;
    return false;
}
//========================================================================




//========================================================================
// 10. find
//------------------------------------------------------------------------
// finds and returns the index to a value.

int find(int *arr, int size, int val)
{
    const int block_size = 8;
    alignas(32) int block[block_size] = {0};

    int start = 0;
    int end = size;

    while(end - start >= block_size)
    {
        int found = 0;
        #pragma omp simd
        for (int i = start; i < end; i++)
        {
            int ret = (arr[i] == val);
            block[i - block_size] = ret;
            found |= ret;
        }

        if (found)
        {
            int i = 0;
            for (i = start; i < start + block_size; i++)
            {
                if (block[i])
                {
                    break;
                }
            }
            return start + i;
        }
        start += block_size;
    }

    while(start != end)
    {
        if (arr[start] == val)
            return start;
        start++;
    }

    return -1;
}
//========================================================================




//========================================================================
// 11. min
//------------------------------------------------------------------------
// returns min value
// It uses #pragma omp simd reduction.

int min_ (int *arr, int size)
{
    int ret = INT_MAX;
    #pragma omp simd reduction(min:ret)
    for (int i = 0; i < size; i++)
    {
        if (arr[i] < ret)
            ret = arr[i];
    }
    return ret;
}
//========================================================================



//========================================================================
// 12. min_element
//------------------------------------------------------------------------
// finds and returns the index to a min value.

int min_element(int *arr, int size)
{
    int val = min_(arr, size); // get the min value
    return find(arr, size, val);
}
//========================================================================
